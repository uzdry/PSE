\documentclass[entwurf.tex]{subfiles}

\begin{document}
\chapter{Vorgänge}
\section{Datenrepräsentanten}
Ein Hauptteil der Kommunikation auf dem Server wird über einen zentralen Bus mit Broker gehandelt. Auf ihm gibt es verschiedene Veröffentlicher und Abonnenten (sogenannte Publisher und Subscriber) die alle  eine abstrakte Klasse 'BusAccess' erweitern.

Alle Nachrichten sind Objekte von Klassen welche die abstrakte Klasse 'Message' erweitern und implementieren. Hier wurden abstrakte Klassen gewählt da mehrere Funktionen zentral implementiert werden andere jedoch, wie z.B. Getter und Setter, von dem Nachrichtentyp abhängen.  

Die Rohnachrichten kommen unter anderem von dem Blutooth-Modul, dass als Publisher die erhaltenen Daten auf den Bus legt.

Auf dem Server gibt es für jedes Endgerät ein Objekt, welches das physische Gerät repräsentiert. Diese Objekte sind Instanzen einer Klasse 'Proxy' und abonnieren die benötigten Signale auf dem Nachrichtenbus. \\
Außerdem besitzt jeder Proxy ein eigenes Objekt der Klasse 'PeerConnection' das für die Verbindung zwischen Server und Client zuständig ist. \\
Die subscribten Daten werden vom Proxy über die PeerConnection an das Endgerät verschickt und wenn Daten von der PeerConnection, also vom Endgerät, ankommen werden diese auf den Bus gelegt.

Aggregierte Funktionen und virtuelle Sensoren sind Instanzen einer Klasse 'VirtualSensor'. Sie abonnieren die benötigten Signale, berechnen neue Werte sobald die Signale ankommen, und legen diese dann als neues Signal wieder auf den Bus. 

Zentral gespeichert werden alle Daten in einer LevelDB-Datenbank. Ihr vorgeschaltet ist eine Klasse die eine Schnittstelle zwischen Datenbank und Bus darstellt. In dieser werden alle Signale und Konfigurationsnachrichten abonniert und dann in der Datenbank gespeichert. Außerdem empfängt diese Klasse auch Befehle über den Bus und kann dann z.B. gewünschte Daten aus der Datenbank auf den Bus legen.

Auf dem Endgerät wird der gleiche Datenbus genutzt wie auf dem Server. Auch hier gibt es einen Proxy mit einer PeerConnection.

Dashes sind dann Subscriber des von ihnen angezeigten Signals. Sie erweitern die Klasse Widget
\section{Chain of Responsibility}

Die Werte der Sensoren und die Werte der aggregierten Funktionen können sich zu beliebigen Zeitpunkten ändern. Die sind als Subscribable Value gespeichert und so wie es im Publish-Subscribe Entwurfsmuster vorgesehen ist, werden alle Objekte, die als Beobachter vorhanden sind bei allen Änderungen benachrichtigt. Die Beobachter sind die Endgerät-Proxys. Wenn die eine Nachricht kriegen (es sind neue Werte vorhanden), schicken Sie diese Information nach dem Chain of Responsibility Prinzip weiter. Die WebRTC-Magic Module konvertieren die Nachrichten in einfache Zeichenketten und leiten die über die bestehende Netzwerkverbindung (sei es entweder LAN oder Internet) weiter. Dafür verwenden die RTC Peer Connections und RTC Data Channels. Die ankommende Zeichenketten auf dem Endgerät werden wiederhergestellt (WebRTC-Magic Modul) und das Endgerät kann die Nachrichtenobjekte behandeln. Die werden genauso dargestellt, wie die losgeschickt worden (vom Endgerät-Proxy). Das Endgerät leitet dann die Nachricht an allen Dashes weiter, für die diese Informationen relevant sind.


\end{document}

