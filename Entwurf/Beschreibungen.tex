\documentclass[entwurf.tex]{subfiles}

\begin{document}
\chapter{Vorgänge}
\section{Datenrepräsentanten}
Ein Hauptteil der Kommunikation auf dem Server wird über einen zentralen Bus mit Broker gehandelt. Auf ihm gibt es verschiedene Veröffentlicher und Abonnenten (sogenannte Publisher und Subscriber) die alle  eine abstrakte Klasse 'BusAccess' erweitern.

Alle Nachrichten sind Objekte von Klassen welche die abstrakte Klasse 'Message' erweitern und implementieren. Diese ist Serializable, also auch die Unterklassen. Hier wurden abstrakte Klassen gewählt da mehrere Funktionen zentral implementiert werden andere jedoch, wie z.B. Getter und Setter, von dem Nachrichtentyp abhängen.  

Die Rohnachrichten kommen unter anderem von dem Blutooth-Modul, dass als Publisher die erhaltenen Daten auf den Bus legt.

Auf dem Server gibt es für jedes Endgerät ein Objekt, welches das physische Gerät repräsentiert. Diese Objekte sind Instanzen einer Klasse 'Proxy' und abonnieren die benötigten Signale auf dem Nachrichtenbus. \\
Außerdem besitzt jeder Proxy ein eigenes Objekt der Klasse 'PeerConnection' das für die Verbindung zwischen Server und Client zuständig ist. \\
Die subscribten Daten werden vom Proxy über die PeerConnection an das Endgerät verschickt und wenn Daten von der PeerConnection, also vom Endgerät, ankommen werden diese auf den Bus gelegt.

Aggregierte Funktionen und virtuelle Sensoren sind Instanzen einer Klasse 'VirtualSensor'. Sie abonnieren die benötigten Signale, berechnen neue Werte sobald die Signale ankommen, und legen diese dann als neues Signal wieder auf den Bus. 

Zentral gespeichert werden alle Daten in einer LevelDB-Datenbank. Ihr vorgeschaltet ist eine Klasse die eine Schnittstelle zwischen Datenbank und Bus darstellt. In dieser werden alle Signale und Konfigurationsnachrichten abonniert und dann in der Datenbank gespeichert. Außerdem empfängt diese Klasse auch Befehle über den Bus und kann dann z.B. gewünschte Daten aus der Datenbank auf den Bus legen.

Auf dem Endgerät wird der gleiche Datenbus genutzt wie auf dem Server. Auch hier gibt es einen Proxy mit einer PeerConnection.

Dashes sind dann Subscriber des von ihnen angezeigten Signals. Sie erweitern die Klasse Widget

\section{Chain of Responsibility}

Die Werte der Sensoren und die Werte der aggregierten Funktionen können sich zu beliebigen Zeitpunkten ändern. Diese sind als subscribable Value gespeichert und so wie es im Publish-Subscribe-Bus Entwurfsmuster vorgesehen ist, werden alle Objekte, die als Beobachter vorhanden sind bei Änderungen der subscribten Werte benachrichtigt. Die Beobachter sind die Endgerät-Proxys. Wenn diese eine Nachricht empfangen (es sind neue Werte vorhanden), schicken Sie diese Information nach dem Chain of Responsibility Prinzip weiter an die PeerConnection. Da die Nachrichten alle Serializable sind kann sehr einfach eine Zeichenkette aus dem Objekt erzeugt werden. Die PeerConnection erhält dann diese Zeichenketten und leiten sie über die bestehende Netzwerkverbindung (sei es entweder LAN oder Internet) weiter. Dafür wird der RTC Data Channel genutzt. Die ankommende Zeichenketten auf dem Endgerät werden durch das Serializable wiederhergestellt und das Endgerät kann die Nachrichtenobjekte behandeln. Die werden genauso dargestellt, wie die losgeschickt worden (vom Endgerät-Proxy). Der Bus leitet dann alle Informationen an die passenden Dashes oder die Einstellungen weiter.

\end{document}

